# ---------------------------------------------------------------
# -------------------------- System settings --------------------
# ---------------------------------------------------------------
# Number of levels per subsystem
nlevels = [2, 2]
# Number of essential levels per subsystem (Default: same as nlevels)
nessential = [2, 2]
# Number of time steps used for time-integration
ntime = 1000
# Time step size (ns). Determines final time: T=ntime*dt
dt = 0.1
# Fundamental transition frequencies (|0> to |1> transition) for each oscillator ("\omega_k", multiplying a_k^d a_k, GHz)
transfreq = [4.10595, 4.81526]
# Self-kerr frequencies for each oscillator ("\xi_k", multiplying a_k^d a_k^d a_k a_k, GHz)
selfkerr = [0.2198, 0.2252]
# Cross-kerr coupling strength for oscillators k<->l ("\xi_kl", multiplying a_k^d a_k a_l^d a_l, GHz).
# Format: table with keys "k-l" (e.g., "0-1") specifying coupling between oscillators k and l. Unspecified couplings default to zero. E.g. { "0-1" = <val>, "2-4" = <val>}
crosskerr = { "0-1" = 0.1 }
# Dipole-dipole coupling strength for oscillators k<->l ("J_kl", multiplying a_k^d a_l + a_k a_l^d, GHz).
# Format: table with keys "k-l" (e.g., "0-1") specifying coupling between oscillators k and l. Unspecified couplings default to zero. E.g. { "0-1" = <val>, "2-4" = <val>}
Jkl = { "0-1" = 0.0 }
# Rotational wave approximation frequencies for each subsystem ("\omega_rot", GHz).
# Note: The target gate rotation can be specified separately with option "gate_rot_freq", see below.
rotfreq = [4.10595, 4.81526]

# Decoherence setting: Switch between Schroedinger and Lindblad solver. Default is "none" which solves Schroedinger equation (state vector dynamics), all other types solve Lindblads master equation for the density matrix.
decoherence = { type = "none",              # "none", "decay", "dephase", or "both"
            #    decay_time = [0.0, 0.0],   # Decay times T1 for each oscillator (ns)
            #    dephase_time = [0.0, 0.0]  # Dephasing times T2 for each oscillator (ns)
              } 
# Specify the initial conditions that are to be propagated
initial_condition = {type = "basis"}
# initial_condition = {type = "basis", oscIDs = [0, 1]}
# initial_condition = {type = "file", filename = "path/to/initial_condition.dat"}
# initial_condition = {type = "product_state", levels = [1, 0]}
# initial_condition = {type = "diagonal", oscIDs = [0]}
# initial_condition = {type = "ensemble", oscIDs = [0, 1]}
# initial_condition = {type = "3states"}
# initial_condition = {type = "nplus1"}
# initial_condition = {type = "performance"}

# Optional: Read system Hamiltonian from file (default: none - use built-in analytical Hamiltonian)
# hamiltonian_file_Hsys = "/path/to/system_hamiltonian.dat"
# Optional: Read control Hamiltonian from file (default: none - use built-in analytical Hamiltonian)
# hamiltonian_file_Hc = "/path/to/control_hamiltonian.dat"

# ---------------------------------------------------------------
# ------------------- Optimization options ----------------------
# ---------------------------------------------------------------
# Decide whether control pulses should start and end at zero. Default: true.
control_enforceBC = false

# Optimization options: "gate" (either read from file, or choose from defaults), or "state" (either read from file, or choose a levels of a product state), or "none" (no optimization)
# Default gate types: "cnot", "cqnot", "swap", "swap0q", "qft", "xgate", "ygate", "zgate", "hadamard"
optim_target = {type = "gate", gate_type = "cnot"}
# optim_target = {type = "gate", filename = "/path/to/target_gate.dat"}
# optim_target = {type = "gate", filename = "/path/to/target_gate.dat", gate_rot_freq = [0.0, 0.0]}
# optim_target = {type = "state", levels = [0, 0]}
# optim_target = {type = "state", filename = "/path/to/target_state.dat"}
#optim_target = {type = "none"}

# Frequency of rotation of the target gate, for each oscillator (GHz). Default: 0.0
# gate_rot_freq = [0.0, 0.0]

# Objective function measure options: "Jtrace", "Jfrobenius", "Jmeasure"
optim_objective = "Jtrace"

# Weights for summing up the objective function (beta_i).
# If fewer numbers than oscillators are given, the last one will be propagated to the remaining ones.
optim_weights = [1.0]
# optim_weights = [0.5, 0.5]

# Optimization tolerances (stopping criteria):
optim_tolerance = { grad_abs = 1e-7,     # absolute gradient norm tolerance (||G|| < grad_abs)
                    grad_rel = 1e-8,     # relative gradient norm tolerance (||G||/||G0|| < grad_rel)
                    final_cost = 1e-5,   # final-time cost tolerance (J(T) < final_cost)
                    infidelity = 1e-5    # infidelity tolerance (1 - F_avg < infidelity)
                }
# Maximum number of optimization iterations
optim_maxiter = 200

# Tikhonov regularization for the optimization variables (gamma * ||x||^2)
optim_tikhonov = { coeff = 0.00001,   # Coefficient (gamma) for Tikhonov regularization
                   use_x0 = false     # use gamma * ||x - x_0||^2 instead (default: false)
                 }

# Coefficients for Penalty terms added to the optimization cost function
optim_penalty = { leakage = 0.0,                # Penalize leakage into guard levels
                  energy = 0.0,                 # Penalize integral over control pulse energy
                  dpdm = 0.0,                   # Penalize 2nd derivative of state populations
                  variation = 0.0,              # Penalize control pulse variation (for 0-th order Bsplines)
                  weightedcost = 0.0,           # Penalize time-weighted cost function integral
                  weightedcost_width = 0.0      # Width paramter for weighted cost function integral
                }

# Frequency of writing information during optimization iterations: write every <num> iterations
optim_monitor_frequency = 1

# ---------------------------------------------------------------
# ------------------- Output and runtypes -----------------------
# ---------------------------------------------------------------
# Directory for output files
datadir = "./data_out"

# Output frequency in the time domain: write output every <num> time-step
output_frequency = 1
# Specify the desired output during time evolution. Format: list of any of the following options:
# "expectedEnergy" - expected level occupation for each oscillator 
# "expectedEnergyComposite" - expected level of the full-dimensional composite system
# "population" - level occupation (probabilities) for each oscillator 
# "populationComposite" - level occupation (probabilities) for the full-dimensional composite system
# "fullstate" - full state of the composite system (full density matrix, or state vector). WARNING: This might result in very large output files - use with care.
output_type = ["population", "expectedEnergy"]

# Runtype options:
# "simulation" - a forward simulation only
# "gradient" - forward simulation and backward simulation
# "optimization" - a full optimization cycle
# "evalControls" - Only evaluates the current control pulses (no simulation)
# "none" - Don't run anything
runtype = "optimization"
# Use matrix free solver, instead of sparse matrix implementation. Only available for 2,3,4, or 5 oscillators.
usematfree = true
# Solver type for solving the linear system at each time step: "gmres", "neumann"
linearsolver_type = "gmres"
# Set maximum number of iterations for the linear solver
linearsolver_maxiter = 20
# Switch the time-stepping algorithm. Currently available:
# "IMR" - Implicit Midpoint Rule (IMR) of 2nd order,
# "IMR4" - Compositional IMR of order 2 using 3 stages,
# "IMR8" - Compositional IMR of order 8 using 15 stages,
# "EE" - Explicit Euler (EE) of 1st order, (for debugging only)
timestepper = "IMR"
# For reproducability, one can choose to set a fixed seed for the random number generator. Comment out, or set negative if seed should be random (non-reproducable)
rand_seed = 1234

# Control initialization options: Table with optional default + per-subsystem overrides

# Option 1: Default initialization that applies to all subsystems 
control_initialization = { type = "random", amplitude = 0.005 }
# control_initialization = { type = "file", filename = "params.dat" }

# Option 2: Per-subsystem initialization (must specify all subsystems you want to customize)
# control_initialization = {
#   "0" = { type = "constant", amplitude = 0.003 },
#   "1" = { type = "random", amplitude = 0.05 }
# }

# Control parameterization options: Table with optional default + per-subsystem overrides
# Available control types:
# "spline" - 2nd order B-spline basis functions (recommended)
# "spline0" - piecewise constant control parameterization (0th order B-splines)
# "spline_amplitude" - amplitude-only parameterization

# Option 1: Default parameterization that applies to all subsystems
control_parameterization = { type = "spline", num = 150}
# control_parameterization = { type = "spline0", num = 300 , tstart = 0.0, tstop = 10.0 }

# Option 2: Per-subsystem parameterization (must specify all subsystems you want to customize)
# control_parameterization = {
#   "0" = { type = "spline", num = 150, tstart = 0.0, tstop = 10.0 },
#   "1" = { type = "spline0", num = 300 }
# }

# Carrier wave frequencies for all oscillators (GHz).
# Option 1: Specify different frequencies for each oscillator (per-subsystem)
carrier_frequency = {
  "0" = [0.0, -0.2198, -0.1],
  "1" = [0.0, -0.2252, -0.1]
}
# Option 2: Same frequencies for all oscillators (uncomment to use)
# carrier_frequency = [0.0, -0.2252, -0.1]

# Maximum amplitude bound for the control pulses (GHz).
# Option 1: Single value applies to all oscillators
control_bounds = 0.008
# Option 2: Per-oscillator values using table format (uncomment to use)
# control_bounds = {
#   "0" = 0.008,
#   "1" = 0.010
# }
